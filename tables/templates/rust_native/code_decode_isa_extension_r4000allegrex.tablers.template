/* SPDX-FileCopyrightText: Â© 2024 Decompollaborate */
/* SPDX-License-Identifier: MIT */

#define HASH #
#define HASH_EXPANSION(x) x
#define SPECIAL_RS_TAG(...) HASH_EXPANSION(HASH)[__VA_ARGS__]

#define RAB_DEF_OPCODE(prefix, case_bits, name, isa_version_min, isa_exten, ...) \
    case_bits => Opcode::prefix##_##name,

#define RAB_DEF_OPCODE_ALTNAME(prefix, case_bits, name, altname, isa_version_min, isa_exten, ...) \
    RAB_DEF_OPCODE(prefix, case_bits, name, isa_version_min, isa_exten, __VA_ARGS__)

#define RAB_DEF_OPCODE_PSEUDO(prefix, name, isa_version_min, isa_exten, ...)

#define RAB_DEF_OPCODE_REDIRECT(case_bits, prefix, kind) \
    case_bits => return Self::decode_isa_extension_## prefix ##_## kind (word, mandatory_bits, flags, isa_version),

#define RAB_DEF_OPCODE_REMOVED(case_bits, prefix, name, isa_version_min, isa_exten) \
    case_bits => Opcode::ALL_INVALID,

use crate::{DecodingFlags, EncodedFieldMask, IsaVersion, Opcode, OpcodeCategory, OpcodeDecoder};

impl OpcodeDecoder {
    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_normal(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::opcode;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_NORMAL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_normal.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_special(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_SPECIAL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_special.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_special_rs(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::rs;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_SPECIAL_RS;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_special_rs.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_special_sa(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::sa;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_SPECIAL_SA;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_special_sa.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_regimm(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::rt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_REGIMM;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_regimm.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_special2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_SPECIAL2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_special2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_special3(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_SPECIAL3;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_special3.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_special3_bshfl(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::sa;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_SPECIAL3_BSHFL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_special3_bshfl.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop0.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor0_bc0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::bc_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP0_BC0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop0_bc0.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor0_tlb(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP0_TLB;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop0_tlb.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop1.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor1_bc1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::bc_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP1_BC1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop1_bc1.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor1_fpu_s(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP1_FPUS;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop1_fpu_s.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor1_fpu_w(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP1_FPUW;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop1_fpu_w.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop2.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor2_bc2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::bc_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP2_BC2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop2_bc2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor2_mfhc2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_mxhc2;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP2_MFHC2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop2_mfhc2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor2_mfhc2_p(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_mfhc2_p_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP2_MFHC2_P;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop2_mfhc2_p.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor2_mfhc2_p_s(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_mfhc2_p_s_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP2_MFHC2_P_S;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop2_mfhc2_p_s.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_coprocessor2_mthc2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_mxhc2;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_COP2_MTHC2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_cop2_mthc2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu0.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu1.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu3(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU3;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu3.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_fmt0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_FMT0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_fmt0.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_fmt2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_FMT2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_fmt2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_fmt3(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_FMT3;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_fmt3.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_rnd(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_RND;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_rnd.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_cvtflt(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_CVTFLT;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_cvtflt.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_cvtint(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_CVTINT;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_cvtint.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_fmt8(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_FMT8;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_fmt8.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_fmt9(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_FMT9;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_fmt9.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_control(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_CONTROL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_control.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_color(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt0_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_COLOR;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_color.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt0_cst(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_tp;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT0_CST;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt0_cst.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt2_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu4_fmt2_cndmove(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu4_fmt2_cndmove_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU4_FMT2_CNDMOVE;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu4_fmt2_cndmove.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu5(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu5_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU5;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu5.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu6(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu6_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU6;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu6.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu6_fmt7(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu6_fmt7_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU6_FMT7;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu6_fmt7.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu6_fmt7_fmt0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu6_fmt7_fmt0_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU6_FMT7_FMT0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu6_fmt7_fmt0.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_quadlr(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_wb;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_QUADLR;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_quadlr.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r4000allegrex_vfpu7(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r4000allegrex_vfpu7_fmt;
        let opcode_category = OpcodeCategory::R4000ALLEGREX_VFPU7;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r4000allegrex/r4000allegrex_vfpu7.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

}

#undef RAB_DEF_OPCODE
#undef RAB_DEF_OPCODE_ALTNAME
#undef RAB_DEF_OPCODE_PSEUDO
#undef RAB_DEF_OPCODE_REDIRECT
#undef RAB_DEF_OPCODE_REMOVED
