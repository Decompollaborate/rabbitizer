/* SPDX-FileCopyrightText: Â© 2024-2025 Decompollaborate */
/* SPDX-License-Identifier: MIT */

#define HASH #
#define HASH_EXPANSION(x) x
#define SPECIAL_RS_TAG(...) HASH_EXPANSION(HASH)[__VA_ARGS__]


#define __IMPL_RAB_DEF_OPCODE(prefix, case_bits, name, altname, isa_version_min, isa_exten, extra_expr, ...) \
    case_bits => { extra_expr Opcode::prefix##_##name },


#define RAB_DEF_OPCODE(prefix, case_bits, name, isa_version_min, ...) \
    __IMPL_RAB_DEF_OPCODE(prefix, case_bits, name, name, IsaVersion:: isa_version_min, None, , __VA_ARGS__)

#define RAB_DEF_OPCODE_ALTNAME(prefix, case_bits, name, altname, isa_version_min, ...) \
    __IMPL_RAB_DEF_OPCODE(prefix, case_bits, name, name, IsaVersion:: isa_version_min, None, , __VA_ARGS__)

#define RAB_DEF_OPCODE_PSEUDO(prefix, name, isa_version_min, ...)


#define RAB_DEF_OPCODE_EXT(prefix, case_bits, name, isa_exten, ...) \
    __IMPL_RAB_DEF_OPCODE(prefix, case_bits, name, name, IsaVersion::EXTENSION, Some(IsaExtension:: isa_exten), , __VA_ARGS__)

#define RAB_DEF_OPCODE_EXT_ALTNAME(prefix, case_bits, name, altname, isa_exten, ...) \
    __IMPL_RAB_DEF_OPCODE(prefix, case_bits, name, name, IsaVersion::EXTENSION, Some(IsaExtension:: isa_exten), , __VA_ARGS__)

#define RAB_DEF_OPCODE_EXT_GATED(prefix, case_bits, name, isa_exten, gate, ...) \
    SPECIAL_RS_TAG(cfg(feature = #gate )) \
    __IMPL_RAB_DEF_OPCODE(prefix, case_bits, name, name, IsaVersion::EXTENSION, Some(IsaExtension:: isa_exten), gated_behind = Some(OpcodeValidityGate:: gate) ;, __VA_ARGS__)

#define RAB_DEF_OPCODE_EXT_REMOVED(case_bits, prefix, name, isa_exten) \
    __IMPL_RAB_DEF_OPCODE(ALL, case_bits, INVALID, INVALID, IsaVersion::EXTENSION, Some(IsaExtension:: isa_exten), )


#define RAB_DEF_OPCODE_REDIRECT(case_bits, prefix, kind) \
    case_bits => return Self::decode_isa_extension_## prefix ##_## kind (word, mandatory_bits, flags, isa_version),


use crate::opcodes::{DecodingFlags, Opcode, OpcodeCategory, OpcodeDecoder};
use crate::isa::IsaVersion;
use crate::encoded_field_mask::EncodedFieldMask;

impl OpcodeDecoder {
    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r3000gte_normal(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::opcode;
        let _opcode_category = OpcodeCategory::CORE_NORMAL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "opcodes/r3000gte/r3000gte_normal.inc"
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r3000gte_coprocessor2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::fmt;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "opcodes/r3000gte/r3000gte_cop2.inc"
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r3000gte_coprocessor2_gte(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R3000GTE_COP2_GTE;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        // GTE instructions are weird
        mandatory_bits = mandatory_bits.union(EncodedFieldMask::r3000gte_fake_opcode.mask_value(word));
        mandatory_bits = mandatory_bits.union(EncodedFieldMask::r3000gte_sf.mask_value(word));
        mandatory_bits = mandatory_bits.union(EncodedFieldMask::r3000gte_mx.mask_value(word));
        mandatory_bits = mandatory_bits.union(EncodedFieldMask::r3000gte_v.mask_value(word));
        mandatory_bits = mandatory_bits.union(EncodedFieldMask::r3000gte_cv.mask_value(word));
        mandatory_bits = mandatory_bits.union(EncodedFieldMask::r3000gte_lm.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r3000gte/r3000gte_cop2_gte.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

}


#undef __IMPL_RAB_DEF_OPCODE

#undef RAB_DEF_OPCODE
#undef RAB_DEF_OPCODE_ALTNAME
#undef RAB_DEF_OPCODE_PSEUDO

#undef RAB_DEF_OPCODE_EXT
#undef RAB_DEF_OPCODE_EXT_ALTNAME
#undef RAB_DEF_OPCODE_EXT_REMOVED

#undef RAB_DEF_OPCODE_REDIRECT
