/* SPDX-FileCopyrightText: Â© 2024 Decompollaborate */
/* SPDX-License-Identifier: MIT */

#define HASH #
#define HASH_EXPANSION(x) x
#define SPECIAL_RS_TAG(...) HASH_EXPANSION(HASH)[__VA_ARGS__]

#define RABBITIZER_DEF_INSTR_ID(prefix, case_bits, name, isa_version, isa_extension, ...) \
    case_bits => opcode = Opcode::prefix##_##name,

#define RABBITIZER_DEF_INSTR_ID_ALTNAME(prefix, case_bits, name, altname, isa_version, isa_extension, ...) \
    RABBITIZER_DEF_INSTR_ID(prefix, case_bits, name, isa_version, isa_extension, __VA_ARGS__)

use crate::{DecodingFlags, EncodedFieldMask, IsaVersion, Opcode, OpcodeCategory, OpcodeDecoder};

impl OpcodeDecoder {
    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_normal(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::opcode;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_NORMAL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_normal.inc"
            _ => return Self::decode_isa_extension_none_normal(word, mandatory_bits, isa_version, flags),
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_special(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_SPECIAL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_special.inc"
            _ => return Self::decode_isa_extension_none_special(word, mandatory_bits, isa_version, flags),
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }.fixups_decode_isa_extension_r5900_special(word, isa_version, flags)
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_regimm(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::rt;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_REGIMM;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_regimm.inc"
            _ => return Self::decode_isa_extension_none_regimm(word, mandatory_bits, isa_version, flags),
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::fmt;
        let _opcode_category = OpcodeCategory::R5900_COP0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
            0x10 => Self::decode_isa_extension_r5900_coprocessor0_tlb(word, mandatory_bits, isa_version, flags),
            _ => Self::decode_isa_extension_none_coprocessor0(word, mandatory_bits, isa_version, flags),
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor0_tlb(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_COP0_TLB;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_cop0_tlb.inc"
            _ => return Self::decode_isa_extension_none_coprocessor0_tlb(word, mandatory_bits, isa_version, flags),
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::fmt;
        let _opcode_category = OpcodeCategory::R5900_COP1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
            0x10 => Self::decode_isa_extension_r5900_coprocessor1_fpu_s(word, mandatory_bits, isa_version, flags),
            _ => Self::decode_isa_extension_none_coprocessor1(word, mandatory_bits, isa_version, flags),
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor1_fpu_s(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_COP1_FPUS;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_cop1_fpu_s.inc"
            _ => return Self::decode_isa_extension_none_coprocessor1_fpu_s(word, mandatory_bits, isa_version, flags),
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_cop2_highbit;
        let opcode = Opcode::r5900_INVALID;
        let opcode_category = OpcodeCategory::R5900_COP2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
            0x00 => return Self::decode_isa_extension_r5900_coprocessor2_nohighbit(word, mandatory_bits, isa_version, flags),
            0x01 => return Self::decode_isa_extension_r5900_coprocessor2_special1(word, mandatory_bits, isa_version, flags),
            _ => {},
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor2_nohighbit(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_cop2_nohighbit_fmt;
        let mut opcode = Opcode::r5900_INVALID;
        let opcode_category = OpcodeCategory::R5900_COP2_NOHIGHBIT;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_cop2.inc"
            0x08 => return Self::decode_isa_extension_r5900_coprocessor2_bc2(word, mandatory_bits, isa_version, flags),
            _ => {},
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor2_bc2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::bc_fmt;
        let mut opcode = Opcode::r5900_INVALID;
        let opcode_category = OpcodeCategory::R5900_COP2_BC2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_cop2_bc2.inc"
            _ => {},
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor2_special1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let mut opcode = Opcode::r5900_INVALID;
        let opcode_category = OpcodeCategory::R5900_COP2_SPECIAL1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_cop2_special1.inc"
            0x3C | 0x3D | 0x3E | 0x3F => return Self::decode_isa_extension_r5900_coprocessor2_special2(word, mandatory_bits, isa_version, flags),
            _ => {},
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor2_special2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_fhi_flo;
        let mut opcode = Opcode::r5900_INVALID;
        let opcode_category = OpcodeCategory::R5900_COP2_SPECIAL2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_cop2_special2.inc"
            0x3C2 | 0x3C3 => return Self::decode_isa_extension_r5900_coprocessor2_viwr(word, mandatory_bits, isa_version, flags),
            _ => {},
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_coprocessor2_viwr(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_viwr_fhilo;
        let mut opcode = Opcode::r5900_INVALID;
        let opcode_category = OpcodeCategory::R5900_COP2_VIWR;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_cop2_viwr.inc"
            _ => {},
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_mmi(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        isa_version: IsaVersion,
        flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_MMI;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_mmi.inc"

            0x08 => return Self::decode_isa_extension_r5900_mmi_0(word, mandatory_bits, isa_version, flags),
            0x09 => return Self::decode_isa_extension_r5900_mmi_2(word, mandatory_bits, isa_version, flags),
            0x28 => return Self::decode_isa_extension_r5900_mmi_1(word, mandatory_bits, isa_version, flags),
            0x29 => return Self::decode_isa_extension_r5900_mmi_3(word, mandatory_bits, isa_version, flags),

            0x30 => return Self::decode_isa_extension_r5900_mmi_pmfhl(word, mandatory_bits, isa_version, flags),
            0x31 => return Self::decode_isa_extension_r5900_mmi_pmthl(word, mandatory_bits, isa_version, flags),

            _ => opcode = Opcode::r5900_INVALID,
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_mmi_0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_mmi_function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_MMI_0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_mmi_0.inc"
            _ => opcode = Opcode::r5900_INVALID,
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_mmi_1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_mmi_function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_MMI_1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_mmi_1.inc"
            _ => opcode = Opcode::r5900_INVALID,
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_mmi_2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_mmi_function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_MMI_2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_mmi_2.inc"
            _ => opcode = Opcode::r5900_INVALID,
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_mmi_3(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_mmi_function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_MMI_3;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_mmi_3.inc"
            _ => opcode = Opcode::r5900_INVALID,
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_mmi_pmfhl(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_mmi_function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_MMI_PMFHL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_mmi_pmfhl.inc"
            _ => opcode = Opcode::r5900_INVALID,
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900_mmi_pmthl(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _isa_version: IsaVersion,
        _flags: &DecodingFlags
    ) -> Self {
        let mask = EncodedFieldMask::r5900_mmi_function;
        let opcode;
        let opcode_category = OpcodeCategory::R5900_MMI_PMTHL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "instr_id/r5900/r5900_mmi_pmthl.inc"
            _ => opcode = Opcode::r5900_INVALID,
        }
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
        }
    }

}

#undef RABBITIZER_DEF_INSTR_ID
#undef RABBITIZER_DEF_INSTR_ID_ALTNAME
