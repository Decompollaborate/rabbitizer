/* SPDX-FileCopyrightText: Â© 2024-2025 Decompollaborate */
/* SPDX-License-Identifier: MIT */

#define HASH #
#define HASH_EXPANSION(x) x
#define SPECIAL_RS_TAG(...) HASH_EXPANSION(HASH)[__VA_ARGS__]

#define RAB_DEF_OPCODE(prefix, case_bits, name, isa_version_min, isa_exten, ...) \
    case_bits => Opcode::prefix##_##name,

#define RAB_DEF_OPCODE_ALTNAME(prefix, case_bits, name, altname, isa_version_min, isa_exten, ...) \
    RAB_DEF_OPCODE(prefix, case_bits, name, isa_version_min, isa_exten, __VA_ARGS__)

#define RAB_DEF_OPCODE_PSEUDO(prefix, name, isa_version_min, isa_exten, ...)

#define RAB_DEF_OPCODE_REDIRECT(case_bits, prefix, kind) \
    case_bits => return Self::decode_isa_extension_## prefix ##_## kind (word, mandatory_bits, flags, isa_version),

#define RAB_DEF_OPCODE_REMOVED(case_bits, prefix, name, isa_version_min, isa_exten) \
    case_bits => Opcode::ALL_INVALID,

#define RAB_DEF_OPCODE_EXTENSION(prefix, case_bits, name, isa_exten, ...) \
    RAB_DEF_OPCODE(prefix, case_bits, name, , Some(IsaExtension:: isa_exten ), __VA_ARGS__)

#define RAB_DEF_OPCODE_EXTENSION_ALTNAME(prefix, case_bits, name, altname, isa_exten, ...) \
    RAB_DEF_OPCODE(prefix, case_bits, name, , Some(IsaExtension:: isa_exten ), __VA_ARGS__)

use crate::opcodes::{DecodingFlags, Opcode, OpcodeCategory, OpcodeDecoder};
use crate::isa::IsaVersion;
use crate::encoded_field_mask::EncodedFieldMask;

impl OpcodeDecoder {
    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_normal(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::opcode;
        let opcode_category = OpcodeCategory::R5900EE_NORMAL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_normal.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_special(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R5900EE_SPECIAL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_special.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }.fixups_decode_isa_extension_r5900ee_special(word, flags, isa_version)
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_regimm(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::rt;
        let opcode_category = OpcodeCategory::R5900EE_REGIMM;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_regimm.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::fmt;
        let _opcode_category = OpcodeCategory::R5900EE_COP0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop0.inc"
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor0_tlb(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R5900EE_COP0_TLB;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop0_tlb.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::fmt;
        let _opcode_category = OpcodeCategory::R5900EE_COP1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop1.inc"
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor1_fpu_s(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R5900EE_COP1_FPUS;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop1_fpu_s.inc"
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_cop2_highbit;
        let opcode_category = OpcodeCategory::R5900EE_COP2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
            RAB_DEF_OPCODE_REDIRECT(0x0, r5900ee, coprocessor2_nohighbit)
            RAB_DEF_OPCODE_REDIRECT(0x1, r5900ee, coprocessor2_special1)
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor2_nohighbit(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_cop2_nohighbit_fmt;
        let opcode_category = OpcodeCategory::R5900EE_COP2_NOHIGHBIT;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor2_bc2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::bc_fmt;
        let opcode_category = OpcodeCategory::R5900EE_COP2_BC2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop2_bc2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor2_special1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R5900EE_COP2_SPECIAL1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop2_special1.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor2_special2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_fhi_flo;
        let opcode_category = OpcodeCategory::R5900EE_COP2_SPECIAL2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop2_special2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_coprocessor2_viwr(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_viwr_fhilo;
        let opcode_category = OpcodeCategory::R5900EE_COP2_VIWR;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_cop2_viwr.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_mmi(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        flags: &DecodingFlags,
        isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::function;
        let opcode_category = OpcodeCategory::R5900EE_MMI;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_mmi.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_mmi_0(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_mmi_function;
        let opcode_category = OpcodeCategory::R5900EE_MMI_0;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_mmi_0.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_mmi_1(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_mmi_function;
        let opcode_category = OpcodeCategory::R5900EE_MMI_1;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_mmi_1.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_mmi_2(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_mmi_function;
        let opcode_category = OpcodeCategory::R5900EE_MMI_2;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_mmi_2.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_mmi_3(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_mmi_function;
        let opcode_category = OpcodeCategory::R5900EE_MMI_3;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_mmi_3.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_mmi_pmfhl(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_mmi_function;
        let opcode_category = OpcodeCategory::R5900EE_MMI_PMFHL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_mmi_pmfhl.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }

    SPECIAL_RS_TAG(must_use)
    pub(crate) const fn decode_isa_extension_r5900ee_mmi_pmthl(
        word: u32,
        mut mandatory_bits: EncodedFieldMask,
        _flags: &DecodingFlags,
        _isa_version: IsaVersion,
    ) -> Self {
        let mask = EncodedFieldMask::r5900ee_mmi_function;
        let opcode_category = OpcodeCategory::R5900EE_MMI_PMTHL;

        mandatory_bits = mandatory_bits.union(mask.mask_value(word));

        let opcode = match mask.get_shifted(word) {
#include "opcodes/r5900ee/r5900ee_mmi_pmthl.inc"
            _ => Opcode::ALL_INVALID,
        };
        Self {
            opcode,
            opcode_category,
            mandatory_bits,
            gated_behind: None,
        }
    }
}

#undef RAB_DEF_OPCODE
#undef RAB_DEF_OPCODE_ALTNAME
#undef RAB_DEF_OPCODE_PSEUDO
#undef RAB_DEF_OPCODE_REDIRECT
#undef RAB_DEF_OPCODE_REMOVED
#undef RAB_DEF_OPCODE_EXTENSION
#undef RAB_DEF_OPCODE_EXTENSION_ALTNAME
